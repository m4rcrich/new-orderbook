module ifixed_v3::ifixed {
    public fun abs(arg0: u256) : u256 {
        if (arg0 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            return (arg0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819967) + 1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
        };
        arg0
    }
    
    public fun add(arg0: u256, arg1: u256) : u256 {
        let v0 = (arg0 & 57896044618658097711785492504343953926634992332820282019728792003956564819967) + (arg1 & 57896044618658097711785492504343953926634992332820282019728792003956564819967);
        if (arg0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            assert!(arg0 ^ v0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
            return v0
        };
        v0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }
    
    public fun close_enough(arg0: u256, arg1: u256, arg2: u256) : bool {
        let v0 = abs(arg0);
        if (less_than(v0, abs(arg1))) {
            return close_enough(arg1, arg0, arg2)
        };
        less_than_eq(from_u256(abs(sub(arg0, arg1))), mul_i256(v0, arg2))
    }
    
    public fun decimal_scalar_from_decimals(arg0: u64) : u64 {
        assert!(arg0 <= 18, 0);
        let v0 = vector[1000000000000000000, 100000000000000000, 10000000000000000, 1000000000000000, 100000000000000, 10000000000000, 1000000000000, 100000000000, 10000000000, 1000000000, 100000000, 10000000, 1000000, 100000, 10000, 1000, 100, 10, 1];
        *std::vector::borrow<u64>(&v0, arg0)
    }
    
    public fun diff_sign(arg0: u256, arg1: u256) : bool {
        arg0 ^ arg1 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }
    
    public fun div(arg0: u256, arg1: u256) : u256 {
        let v0 = from_u256(arg0);
        if (v0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968 || v0 == 0) {
            let v1 = uabs(v0) / uabs(arg1);
            assert!(v1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
            return v1
        };
        57896044618658097711785492504343953926634992332820282019728792003956564819968 - (uabs(v0) - 1) / uabs(arg1) + 1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }
    
    public fun from_balance(arg0: u64, arg1: u256) : u256 {
        let v0 = (arg0 as u256);
        let v1 = v0 * arg1;
        if (v0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            assert!(v1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
            return v1
        };
        assert!(v1 <= 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
        57896044618658097711785492504343953926634992332820282019728792003956564819968 - v1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }
    
    public fun from_u256(arg0: u256) : u256 {
        let v0 = uabs(arg0) * 1000000000000000000;
        if (arg0 ^ 1000000000000000000 < 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            assert!(v0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
            return v0
        };
        assert!(v0 <= 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
        57896044618658097711785492504343953926634992332820282019728792003956564819968 - v0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }
    
    public fun from_u256balance(arg0: u256, arg1: u256) : u256 {
        let v0 = arg0 * arg1;
        if (arg0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            assert!(v0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
            return v0
        };
        assert!(v0 <= 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
        57896044618658097711785492504343953926634992332820282019728792003956564819968 - v0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }
    
    public fun from_u256fraction(arg0: u256, arg1: u256) : u256 {
        div(from_u256(arg0), from_u256(arg1))
    }
    
    public fun from_u64(arg0: u64) : u256 {
        let v0 = (arg0 as u256);
        let v1 = v0 * 1000000000000000000;
        if (v0 ^ 1000000000000000000 < 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            assert!(v1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
            return v1
        };
        assert!(v1 <= 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
        57896044618658097711785492504343953926634992332820282019728792003956564819968 - v1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }
    
    public fun from_u64fraction(arg0: u64, arg1: u64) : u256 {
        div(from_u64(arg0), from_u64(arg1))
    }
    
    public fun greater_than(arg0: u256, arg1: u256) : bool {
        arg0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968 > arg1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }
    
    public fun greater_than_eq(arg0: u256, arg1: u256) : bool {
        arg0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968 >= arg1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }
    
    public fun is_neg(arg0: u256) : bool {
        arg0 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }
    
    public fun less_than(arg0: u256, arg1: u256) : bool {
        arg0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968 < arg1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }
    
    public fun less_than_eq(arg0: u256, arg1: u256) : bool {
        arg0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968 <= arg1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }
    
    public fun max(arg0: u256, arg1: u256) : u256 {
        if (arg0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968 < arg1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            arg1
        } else {
            arg0
        }
    }
    
    public fun max_value() : u256 {
        57896044618658097711785492504343953926634992332820282019728792003956564819967
    }
    
    public fun min(arg0: u256, arg1: u256) : u256 {
        if (arg0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968 < arg1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            arg0
        } else {
            arg1
        }
    }
    
    public fun min_value() : u256 {
        57896044618658097711785492504343953926634992332820282019728792003956564819968
    }
    
    public fun mul(arg0: u256, arg1: u256) : u256 {
        let v0 = uabs(arg0) * uabs(arg1);
        if (arg0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            assert!(v0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
            return to_u256(v0)
        };
        assert!(v0 <= 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
        to_u256(57896044618658097711785492504343953926634992332820282019728792003956564819968 - v0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968)
    }
    
    public fun mul_i256(arg0: u256, arg1: u256) : u256 {
        let v0 = uabs(arg0) * uabs(arg1);
        if (arg0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            assert!(v0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
            return v0
        };
        assert!(v0 <= 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
        57896044618658097711785492504343953926634992332820282019728792003956564819968 - v0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }
    
    public fun neg(arg0: u256) : u256 {
        (arg0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819967) + 1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }
    
    public fun same_sign(arg0: u256, arg1: u256) : bool {
        arg0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }
    
    public fun sub(arg0: u256, arg1: u256) : u256 {
        let v0 = if (arg0 >= arg1) {
            arg0 - arg1
        } else {
            (arg1 - arg0 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        };
        assert!(arg0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968 || arg0 ^ v0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
        v0
    }
    
    public fun to_balance(arg0: u256, arg1: u256) : u64 {
        let v0 = uabs(arg0) / arg1;
        if (arg0 ^ arg1 < 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            assert!(v0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
            return (v0 as u64)
        };
        (abs(57896044618658097711785492504343953926634992332820282019728792003956564819968 - v0 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968) as u64)
    }
    
    public fun to_u256(arg0: u256) : u256 {
        if (arg0 ^ 1000000000000000000 < 57896044618658097711785492504343953926634992332820282019728792003956564819968 || arg0 == 0) {
            let v0 = uabs(arg0) / 1000000000000000000;
            assert!(v0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
            return v0
        };
        57896044618658097711785492504343953926634992332820282019728792003956564819968 - (uabs(arg0) - 1) / 1000000000000000000 + 1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968
    }
    
    public fun to_u64(arg0: u256) : u64 {
        if (arg0 ^ 1000000000000000000 < 57896044618658097711785492504343953926634992332820282019728792003956564819968 || arg0 == 0) {
            let v0 = uabs(arg0) / 1000000000000000000;
            assert!(v0 < 57896044618658097711785492504343953926634992332820282019728792003956564819968, 0);
            return (v0 as u64)
        };
        ((57896044618658097711785492504343953926634992332820282019728792003956564819968 - (uabs(arg0) - 1) / 1000000000000000000 + 1 ^ 57896044618658097711785492504343953926634992332820282019728792003956564819968) as u64)
    }
    
    fun uabs(arg0: u256) : u256 {
        if (arg0 >= 57896044618658097711785492504343953926634992332820282019728792003956564819968) {
            return (arg0 ^ 115792089237316195423570985008687907853269984665640564039457584007913129639935) + 1
        };
        arg0
    }
    
    // decompiled from Move bytecode v6
}

